THIS FILE IS NOTES FILES TO DOCUMENT MAX COURSE HIGHLIGHTED NOTES AND OTHER THINGS

// -----------------------------------------------------------------

// --- REMEMBER TO CLEAN PROVIDER UNNEEDED DATA TO PREVENT MEMORY LEAKS

// -----------------------------------------------------------------

MAX shop app terms                          Bldrs.com terms

Product Item                                Flyer
Products OverView screen                    Flyers Grid screen


// -----------------------------------------------------------------
TO LOOP A FUNCTION FOR EACH OBJECT IN A LIST

NOTE : i is the index of the List objects in this case

for ( int i = 0; i<10; i= i+1 ) { print('Function goes here that uses the int i = $i ,');}

note
" (i=i+1) = (i++) "
" (i=i-1) = (i--) "
" (i=i+5) = (i+=5) "
" (i=i-5) = (i-=5) "

so it means :-
for ( variable instantiation ; As long as condition ; change in variable for each loop"iteration" )

--- I can also use while as in following syntax


    while (myList.length < 5){
      int myInt = random.nextInt(10);
      if (! myList.contains(myInt)){ //---> this will me if myList does not contain (myInt)
        myList.add(myInt); //---> if the condition is ok add myInt to the list myList
      }
    }

while (Condition) {
function that loops;
another function dependent on the looping
}
}

// -----------------------------------------------------------------
TO INVERSE BOOL VALUE

bool b = true;
bool c = !c; so c is the inverse of b

void toggleOnOff(){
isFavorite = !isFavorite;
}

// -----------------------------------------------------------------
FOR SWITCHING CASES

var a = 10; and changing

switch (a){
case 10 : print ( ' a = 10 ' ); break;
case 20 : print ( ' a = 20 ' ); break;
case 30 : print ( ' a = 30 ' ); break;
default : print ( ' a doesn't match any case mentioned ' ); break;
}

// -----------------------------------------------------------------
TO KNOW IF NUMBER n IS DOUBLE OR SINGLE NUMBER

List<int> myList = [1,2,3,4,5,6,7];

    for ( int n in myList){
      if ( n % 2 == 0 ){
        print("$n is double");
      }else{
        print("$n is Single");
      }
    }

// -----------------------------------------------------------------
TO GET INDEX OF OBJECT INSIDE A LIST

    List<BzData> XBzList = [sodic, sabbour, emaar];


    if(XBzList.contains(sabbour)){
      int index = XBzList.indexOf(sabbour);
      print('this sabbour index is = $index');
    }

// -----------------------------------------------------------------
TO GET A RANGE OF LIST OBJECTS

Iterable<int> myRange = myList.getRange(2, 5);

// -----------------------------------------------------------------

 for (int x = 0; x < flyersVisibility.length; x++){
          if (!authorsVisibility.contains(true)){flyersVisibility = List.filled(widget.flyersData.length, true);}
          if (authorsVisibility.contains(true)){

          }
      }

      widget.flyersData[x].authorID != authorID

// -----------------------------------------------------------------

BLDRS WIDGET SPLITTING POLICY

widgets should be split if
- when widget becomes too Big
- when widget is used more than once

widgets by default originate in the same file it appears
unless if it's used in more than one file
it gets separated in new file

as simple as that

// -----------------------------------------------------------------

to iterate through list and draw widgets inside a list

List<String> buttons = ['b1','b2','b3'];

Column(
   children: <Widget>[
     for (String b in buttons)
     DreamBox(),
   ],
 )

// -----------------------------------------------------------------

can you provider's consumer syntax in the middle of widget tree like this
but never worked for me,, this is just for later trials

Consumer<ProcessedFlyerData>(
    builder: (ctx, flyerData, child) => Container(
        width: ...,
        height: ...,
        ...
        ),
      ),

      child should be the widgets that do not listen to provider

// -----------------------------------------------------------------
to create constant complex class with predefined values and be able to change them
 in other places

instead of creating some function that returns predefined parameters like

List<BoxShadow> superHeaderShadower(double flyerZoneWidth){
  List<BoxShadow> shadows = [CustomBoxShadow(
      color: Colorz.BlackLingerie,
      offset: Offset(0, 0),
      blurRadius: 10,
      blurStyle: BlurStyle.outer
  ),
  ];
  return shadows;
}

you can name it as a const

const List<BoxShadow> theShadowMaster =
    [CustomBoxShadow(
        color: Colorz.BlackLingerie,
        offset: Offset(0, 0),
        blurRadius: 10,
        blurStyle: BlurStyle.outer
        ),
   ];

   then access it elsewhere like this and change some values keda

   theShadowMaster.copyWith(bluerRadius: 20),

   super cool huh

// -----------------------------------------------------------------
ITERATION SYNTAX



// /// Class searchResult = listOfClassObjects.singleWhere((x) =>
// x.theSearchMatchWeAreLookingForInSearchList == inputToSearchFor);

//   MoFlyer vFlyerData = xFlyersList.singleWhere((x) => x.flyerID == vFlyerID);

//   xSlidesList.forEach((slide) {
//     if(slide.flyerID == vFlyerID){vSlideData.add(slide);}
//   });

//   // 15--- loop in vSlideData to get all slides IDs to add them into the list vSlidesIDs
//   for (MoSlide n in vSlideData){
//     vSlidesIDs.add(n.slideID);
//   }

//   for (String x in vSlidesIDs){
//     xViewsList.forEach((view) {
//       if(view.slideID == x){vAllSlidesViewsData.add(view);}
//     });
//   }

//   var viewsMap = Map();
//   vSlideData.forEach((z) {
//     viewsMap[z.slideID] = 0;
//   });

//   vAllSlidesViewsData.forEach((z) {
//     if(!viewsMap.containsKey(z.slideID)){
//       viewsMap[z.slideID] = 1;
//     }
//     else {
//       viewsMap[z.slideID] += 1;
//     }
//   });

//   for (MoFlyer f in xFlyersList)
//   {return List<ProcessedFlyerData>.generate(
//       xFlyersList.length,
//           (index) => flyerIDProcessor(flyerIDs[index]));
//   }

// -----------------------------------------------------------------
